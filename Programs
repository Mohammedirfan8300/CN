point to point duplex
set ns [new Simulator] / Letter S is capital */

set nf [open lab1.nam w] / open a nam trace file in write mode/

Sns namtrace-all Suf /nf-nam file */

set tf [open lab1.tr w] / tf-trace file "/

Sns trace-all Stf

proc finish {} { provide space b/w proc and finish and all are in small case */

global ns nf tf

Sus flush-trace clears trace file contents */

close Snf

close Stf

exec nam labi. nam &

exit 0

}

set no [Sns node] / creates 4 nodes */

set n1 [Sns node]

set n2 [Sns node]

set 13 [Sns node]
Sns duplex-link $n0 $n2 200Mb 10ms DropTail/*Letter M is capital Mb*/ Sus duplex-link $n1 $n2 100Mb 5ms DropTail /*D and T are capital*/ Sns duplex-link $n2 $n3 1Mb 1000ms DropTail

Sns queue-limit $no Sn2 10 Sns queue-limit Sn1 Sn2 10

set udp0 [new Agent/UDP] / Letters A,U.D and P are capital */ Sns attach-agent $no $udpo

set cbro [new Application/Traffic/CBR] / A.T.C.B and R are capital*/ Scbro set packetSize_500/*S is capital, space after underscore*/ $cbro set interval 0.005 Scbro attach-agent Sudpo

set udp1 [new Agent/UDP] Sns attach-agent $n1 $udp1

set cbr1 [new Application/Traffic/CBR] Scbrl attach-agent Sudp1
set udp2 [new Agent/UDP] Sns attrach-agent $n2 Sudp2

set cbr2 [new Application/Traffic/CBR] $cbr2 attach-agent Sudp2

set nullo [new Agent/Null] /* A and N are capital */ Sns attach-agent $13 $nullo.

$ns connect $udp0 $nullo Sns connect $udp1 $nullo

$ns at 0.1 "$cbro start" $ns at 0.2 "$cbr1 start" Sns at 1.0 "finish"

Sns run
AWK file (Open a new editor using "vi command" and write awk file and save with ".awk" extension)

"immediately after BEGIN should open braces **

BEGIN (

c=0;

If ($1=="d")

{

c++:

printf("%s\t%s\n".$5.511):

} /*immediately after END should open braces {"

END{

printf("The number of packets dropped =%d\n".c);






ethernet lan 
set ns [new Simulator]

set tf [open lab3.tr w]

$ns trace-all Stf

set of [open lab3.nam w]

$ns namtrace-all Suf

set no [Sus node]

$no color "magenta"

$no label "src"

set nl [Sns node]

set 12 [$ns node]

$n2 color "magenta"

$n2 label "sre2"

set n3 [Sus node]

$n3 color "blue"

$n3 label "dest2"

set n4 [Sus node]

set n5 [5ns node]

$n5 color "blue"

Sn5 1

abel "dest1"
$ns make-lan "SnO $nl Sn2 $n3 $n4" 100Mb 100ms LL Queue DropTail Mac/802 3 should come in single line

$ns duplex-link Sn4 $n5 1Mb Ims Drop Tail

set tep0 [new Agent/TCP]

$ns attach-agent $n0 $tep0

set ftp0 [new Application/FTP]

$ftpo attach-agent Step0

$ftp0 set packetSize_500

$ftp0 set interval 0.0001

set sink5 [new Agent/TCPSink]

Sus attach-agent $n5 $sink5

$ns connect Step0 $sink5

set tep2 [new Agent/TCP]

Sns attach-agent Sn2 Step2

set ftp2 [new Application/FTP]

$ftp2 attach-agent Step2

$ftp2 set packetSize 600

$ftp2 set interval 0.001

set sink3 [new Agent/TCPSink]

$ns attach-agent $n3 $sink3.

$ns connect Step2 $sink3
set filel [open filel.tr w]

Stepo attach $filel

set file2 [open file2.tr w]

Step2 attach $file2

Stepo trace ewnd must put underscore() after ewnd and no space between them

Step2 trace ewnd

proc finish () (

Sns flush-trace

global ns nf tf close $tf close Snf exec nam lab3 nam &

exit 0

} Sus at 0.1 "$ftpo start"

5ns at 5 "$ftpo stop"

Sus at 7 "$ftp0 start"

Sus at 0.2 "Sftp2 start"

Sns at & "$ftp2 stop"

Sas at 14 "$ftpo stop"

Sns at 10 "$ftp2 start"

Sns at 15 "$ftp2 stop"

Sns at 16 "finish"

Sis run

AWK file (Open a new editor using "vi command" and write awk file and save with ".awk" extension)

cwnd:- means congestion window

BEGIN {

{ if($6=="cwnd") don't leave space after writing ewnd printf("%f\r%f\r\n",$1,57); /* you must put \n in printf/

END (











///Datagram socket///
import java.net.*;

public class UDPC {
    public static void main(String[] args) {
        DatagramSocket skt;
        try {
            // Create DatagramSocket
            skt = new DatagramSocket();

            // Message to send
            String msg = "udp";
            byte[] b = msg.getBytes();

            // Server details
            InetAddress host = InetAddress.getByName("127.0.0.1");
            int serverSocket = 6788;

            // Send the request packet
            DatagramPacket request = new DatagramPacket(b, b.length, host, serverSocket);
            skt.send(request);

            // Prepare buffer to receive the reply
            byte[] buffer = new byte[1000];
            DatagramPacket reply = new DatagramPacket(buffer, buffer.length);

            // Receive the reply
            skt.receive(reply);

            // Print the received message
            System.out.println("Client received: " + new String(reply.getData(), 0, reply.getLength()));

            // Close the socket
            skt.close();
        } catch (Exception ex) {
            // Silently handle exceptions
        }
    }
}


import java.net.*;

public class UDPS {

    public static void main(String[] args) {
        DatagramSocket skt = null;

        try {
            // Create a DatagramSocket at port 6788
            skt = new DatagramSocket(6788);

            // Prepare a buffer to receive messages
            byte[] buffer = new byte[1000];

            // Server runs infinitely
            while (true) {
                // Receive the request
                DatagramPacket request = new DatagramPacket(buffer, buffer.length);
                skt.receive(request);

                // Process the request
                String message = new String(request.getData(), 0, request.getLength());
                String[] messageParts = message.split(" ");
                String responseMessage = messageParts[0] + " Network Laboratory";

                // Prepare and send the response
                byte[] sendMsg = responseMessage.getBytes();
                DatagramPacket reply = new DatagramPacket(
                        sendMsg, 
                        sendMsg.length, 
                        request.getAddress(), 
                        request.getPort()
                );
                skt.send(reply);

                // Print the response
                System.out.println("Server sent: " + responseMessage);
            }

        } catch (Exception ex) {
            // Handle exceptions silently
        } finally {
            if (skt != null && !skt.isClosed()) {
                skt.close();
            }
        }
    }
}







///*Bellman Ford*///
import java.util.Scanner; 
public class BellmanFord 
{ 
private int D[]; private int num_ver; 
public static final int MAX_VALUE = 999; 
public BellmanFord(int num_ver) 
{ 
this.num_ver = num_ver; D = new int[num_ver + 1]; 
} 
public void BellmanFordEvaluation(int source, int A[][]) 
{ 
for (int node = 1; node <= num_ver; node++) 
{ 
D[node] = MAX_VALUE;  } 
D[source] = 0; 
for (int node = 1; node <= num_ver - 1; node++) 
{ 
for (int sn = 1; sn <= num_ver; sn++) 
{ 
for (int dn = 1; dn <= num_ver; dn++) 
{ 
if (A[sn][dn] != MAX_VALUE) 
{ 
if (D[dn] > D[sn]+ A[sn][dn]) 
D[dn] = D[sn] + A[sn][dn];          }  }  }  }
for (int sn = 1; sn <= num_ver; sn++) 
{ 
for (int dn = 1; dn <= num_ver; dn++) 
{ 
if (A[sn][dn] != MAX_VALUE) 
{ 
if (D[dn] > D[sn]+ A[sn][dn]) 
System.out.println("The Graph contains negative egde cycle"); 
}  }  } 
for (int vertex = 1; vertex <= num_ver; vertex++)
{ 
System.out.println("distance of source " + source + " to "+ vertex + " is " + D[vertex]);   }  }
public static void main(String[ ] args)  { 
int num_ver = 0; int source; 
Scanner scanner = new Scanner(System.in);
 System.out.println("Enter the number of vertices");
 num_ver = scanner.nextInt(); 
int A[][] = new int[num_ver + 1][num_ver + 1]; 
System.out.println("Enter the adjacency matrix"); 
for (int sn = 1; sn <= num_ver; sn++)  { 
for (int dn = 1; dn <= num_ver; dn++)
{
A[sn][dn] = scanner.nextInt(); if (sn == dn) 
{ 
A[sn][dn] = 0; continue; 
} 
if (A[sn][dn] == 0) 
{ 
A[sn][dn] = MAX_VALUE;  }  }  } 
System.out.println("Enter the source vertex"); source = scanner.nextInt(); 
BellmanFord b = new BellmanFord (num_ver); b.BellmanFordEvaluation(source, A); scanner.close();  }  }



///*Leaky Bucket*///
import java.io.*; import java.util.*; 
class Queue 
{ 
int q[],f=0,r=0,size; 
void insert(int n) 
{ 
Scanner in = new Scanner(System.in); 
q=new int[10]; 
for(int i=0;i<n;i++) 
{ 
System.out.print("\nEnter " + i + " element: "); 
int ele=in.nextInt(); 
if(r+1>10) 
{ 
System.out.println("\nQueue is full \nLost Packet: "+ele); 
break; 
}
else 
{  } } } 
r++; 
q[i]=ele; 

void delete() 
{ 
Scanner in = new Scanner(System.in); Thread t=new Thread(); 
if(r==0) 
System.out.print("\nQueue empty "); 
else 
{ 
for(int i=f;i<r;i++) 
{ 
try 
{ 
t.sleep(1000);   }
catch(Exception e)
{       } 
System.out.print("\nLeaked Packet: "+q[i]); f++; 
} 
} 
System.out.println(); 
}    } 
class Leaky extends Thread 
{ 
public static void main(String ar[]) throws Exception 
{  } 
Queue q=new Queue(); 
Scanner src=new Scanner(System.in); 
System.out.println("\nEnter the packets to be sent:");
q. insert(size); q.delete(); 
int size=src.nextInt(); 
}  }
